package me.ciruu.abyss.modules.exploit;

import com.google.common.collect.EvictingQueue;
import com.google.common.collect.Lists;
import com.google.common.collect.Queues;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Queue;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Predicate;
import me.ciruu.abyss.Class248;
import me.ciruu.abyss.Class50;
import me.ciruu.abyss.Class66;
import me.ciruu.abyss.Globals;
import me.ciruu.abyss.enums.Class11;
import me.ciruu.abyss.enums.Class246;
import me.ciruu.abyss.enums.Class247;
import me.ciruu.abyss.events.network.EventNetworkPrePacketEvent;
import me.ciruu.abyss.modules.Module;
import me.ciruu.abyss.settings.Setting;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.network.play.server.SPacketChunkData;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraftforge.event.world.ChunkEvent;

public class ChunkLogger
extends Module {
    private final Setting maxChunks = new Setting("MaxChunks", "Maximum chunks to render (set to 0 for infinite)", (Module)this, (Object)5210, 0, 20000);
    private final Setting clearOnToggle = new Setting("ClearOnToggle", "Clear chunk list on disable", this, true);
    private final Setting showOnly = new Setting("ShowOnly", "Specify which chunk to only show", this, (Object)Class247.ALL);
    private final Setting detectionMethod = new Setting("DetectionMethod", "Specify the method to detect new chunks. Currently only IS_FULL_CHUNK is supported.", this, (Object)Class246.IS_FULL_CHUNK);
    private final Setting flagTiming = new Setting("FlagTiming", "Maximum time in MS that another chunk load in succession will trigger it to be marked as a new chunk", (Module)this, (Object)Float.valueOf(0.0f), Float.valueOf(1000.0f), Float.valueOf(10000.0f));
    private final Setting blockChangeThreshold = new Setting("BlockChangeThreshold", "Maximum number of blocks required to change between chunk loading in order to be marked as a new chunk", (Module)this, (Object)100, 0, 2000);
    private final Lock Field658 = new ReentrantLock();
    private Queue Field659 = null;
    @EventHandler
    private Listener Field660 = new Listener<ChunkEvent.Load>(this::Method942, new Predicate[0]);
    @EventHandler
    private Listener Field661 = new Listener<EventNetworkPrePacketEvent>(this::Method943, new Predicate[0]);
    @EventHandler
    private Listener Field662 = new Listener<Class66>(this::Method944, new Predicate[0]);

    public ChunkLogger() {
        super("ChunkLogger", "", Class11.EXPLOIT);
        this.Method945(this.maxChunks);
        this.Method945(this.clearOnToggle);
        this.Method945(this.showOnly);
        this.Method945(this.detectionMethod);
        this.Method945(this.flagTiming);
        this.Method945(this.blockChangeThreshold);
    }

    void Method946(SPacketChunkData sPacketChunkData) {
        block2: {
            if (this.Field659 == null) break block2;
            this.Field658.lock();
            Class248 class248 = new Class248(this, sPacketChunkData);
            Class248 class2482 = this.Field659.stream().filter(class248::equals).findAny().orElse(null);
            if (class2482 != null) {
                class2482.Method947(sPacketChunkData);
                this.Field659.remove(class2482);
                this.Field659.add(class2482);
            } else {
                this.Field659.add(class248);
            }
            this.Field658.unlock();
        }
    }

    public void Method948() {
        super.Method13();
        this.Field658.lock();
        this.Field659 = (Integer)this.maxChunks.getValue() <= 0 ? Queues.newArrayDeque() : EvictingQueue.create((Integer)this.maxChunks.getValue());
        this.Field658.unlock();
    }

    public void Method949() {
        block0: {
            super.Method15();
            if (!((Boolean)this.clearOnToggle.getValue()).booleanValue() || this.Field659 == null) break block0;
            this.Field658.lock();
            this.Field659.clear();
            this.Field659 = null;
            this.Field658.unlock();
        }
    }

    private void Method944(Class66 class66) {
        if (this.Field659 == null) {
            return;
        }
        this.Field658.lock();
        ArrayList arrayList = Lists.newArrayList(this.Field659);
        this.Field658.unlock();
        arrayList.forEach(this::Method950);
    }

    private void Method950(Class248 class248) {
        switch ((Class247)((Object)this.showOnly.getValue())) {
            case NEW_ONLY: {
                if (class248.Method951()) break;
                return;
            }
            case OLD_ONLY: {
                if (!class248.Method951()) break;
                return;
            }
        }
        int n = class248.Method951() ? Color.WHITE.getRGB() : Color.RED.getRGB();
        AxisAlignedBB axisAlignedBB = new AxisAlignedBB(class248.Field666.minX - Globals.mc.getRenderManager().viewerPosX, class248.Field666.minY - Globals.mc.getRenderManager().viewerPosY, class248.Field666.minZ - Globals.mc.getRenderManager().viewerPosZ, class248.Field666.maxX - Globals.mc.getRenderManager().viewerPosX, class248.Field666.minY - Globals.mc.getRenderManager().viewerPosY, class248.Field666.maxZ - Globals.mc.getRenderManager().viewerPosZ);
        Class50.Method851(axisAlignedBB, 1.0f, n);
    }

    private void Method943(EventNetworkPrePacketEvent eventNetworkPrePacketEvent) {
        if (eventNetworkPrePacketEvent.Method49() instanceof SPacketChunkData) {
            SPacketChunkData sPacketChunkData = (SPacketChunkData)eventNetworkPrePacketEvent.Method49();
            this.Method946(sPacketChunkData);
        }
    }

    private void Method942(ChunkEvent.Load load) {
        if (this.Field659 != null) {
            // empty if block
        }
    }

    static Setting Method952(ChunkLogger chunkLogger) {
        return chunkLogger.flagTiming;
    }

    static Setting Method953(ChunkLogger chunkLogger) {
        return chunkLogger.detectionMethod;
    }
}
